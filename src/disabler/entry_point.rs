use std::{
    ptr::null_mut,
    sync::{
        LazyLock,
        atomic::{AtomicU64, Ordering::Relaxed},
    },
    time::{Duration, Instant},
};

use pelite::pe::Pe;
use windows_sys::Win32::{
    Foundation::{HANDLE, NTSTATUS},
    System::{
        Diagnostics::Debug::{CONTEXT, CONTEXT_FULL_AMD64, GetThreadContext},
        Threading::{
            GetCurrentProcess, GetCurrentThreadId, GetThreadId, ResumeThread, SuspendThread,
            THREAD_ACCESS_RIGHTS, THREAD_ALL_ACCESS, THREAD_QUERY_INFORMATION,
            THREAD_SUSPEND_RESUME,
        },
    },
};

#[link(name = "ntdll", kind = "raw-dylib")]
unsafe extern "C" {
    fn NtGetNextThread(
        process_handle: HANDLE,
        thread_handle: HANDLE,
        desired_access: THREAD_ACCESS_RIGHTS,
        handle_attributes: u32,
        flags: u32,
        new_thread_handle: *mut HANDLE,
    ) -> NTSTATUS;

    fn NtQueryInformationThread(
        thread_handle: HANDLE,
        thread_information_class: u32,
        thread_information: *mut (),
        thread_information_length: usize,
        return_length: *mut usize,
    ) -> NTSTATUS;

    fn RtlUserThreadStart(function: Option<extern "C" fn(*mut ()) -> NTSTATUS>, parameter: *mut ());
}

use fxhash::FxHashMap;

use crate::{analysis::ImageView, disabler::game::game};

/// Find the virtual address of the global security cookie.
///
/// This is designed to work for MSVC binaries, but the pattern used might work on code
/// generated by other compilers.
///
/// The binary must have at least a few 10s of stack-protected functions for the analysis to be
/// successful.
fn find_gs_cookie_va(image: impl ImageView) -> Option<u64> {
    use memchr::memmem;

    const XOR_RAX_RSP: &[u8; 3] = b"\x48\x33\xc4";
    const MIN_COUNT: usize = 16;

    let mut va_counts: FxHashMap<u64, usize> = FxHashMap::default();

    image
        .sections()
        .flat_map(|(va, slice)| memmem::find_iter(slice, XOR_RAX_RSP).map(move |o| va + o as u64))
        .filter_map(|xor_va| {
            let offset = i32::from_le_bytes(image.read(xor_va - 4, 4)?[..4].try_into().unwrap());
            xor_va.checked_add_signed(offset.into())
        })
        .find(|&gs_cookie| {
            let count = va_counts.entry(gs_cookie).or_default();
            *count += 1;
            *count >= MIN_COUNT
        })
}

pub unsafe fn wait_for_gs_cookie(timeout: Option<Duration>) -> Result<(), &'static str> {
    static GS_COOKIE_ADDR: LazyLock<Option<u64>> = LazyLock::new(|| find_gs_cookie_va(game().pe));

    const UNITNIT_GS_COOKIE: u64 = 0x2b992ddfa232;

    let gs_cookie_addr = GS_COOKIE_ADDR.ok_or("global security cookie not found")?;
    let gs_cookie_ptr = unsafe { AtomicU64::from_ptr(gs_cookie_addr as *mut u64) };

    let ts = Instant::now();

    // Poll GS cookie every 10ms until it is no longer equal to the uninitialized value
    while timeout.is_none_or(|timeout| ts.elapsed() < timeout) {
        if gs_cookie_ptr.load(Relaxed) != UNITNIT_GS_COOKIE {
            return Ok(());
        }

        std::thread::sleep(Duration::from_millis(10));
    }
    Err("timed out waiting for __security_init_cookie")
}

/// Iterate over all threads in the current process, getting handles with the requested access
/// rights.
///
/// If `access` is `None`, the default rights of [`THREAD_ALL_ACCESS`] are used.
pub fn iter_threads(access: Option<THREAD_ACCESS_RIGHTS>) -> impl Iterator<Item = HANDLE> {
    let access = access.unwrap_or(THREAD_ALL_ACCESS);
    let proc = unsafe { GetCurrentProcess() };
    let mut thread: HANDLE = null_mut();

    std::iter::from_fn(move || unsafe {
        let status = NtGetNextThread(proc, thread, access, 0, 0, &mut thread);
        if status < 0 || thread.is_null() {
            return None;
        }
        Some(thread)
    })
}

pub struct SuspendGuard {
    suspended: Vec<HANDLE>,
}

impl SuspendGuard {
    pub unsafe fn suspend_all_threads() -> Self {
        log::debug!("suspending all threads");

        unsafe {
            let current_thread = GetCurrentThreadId();

            let suspended = iter_threads(Some(THREAD_SUSPEND_RESUME | THREAD_QUERY_INFORMATION))
                .filter(|&h| GetThreadId(h) != current_thread && SuspendThread(h) != 0)
                .collect();

            Self { suspended }
        }
    }
}

impl Drop for SuspendGuard {
    fn drop(&mut self) {
        log::debug!("resuming threads");
        for thread in std::mem::take(&mut self.suspended) {
            unsafe { ResumeThread(thread) };
        }
    }
}

pub fn process_main_thread() -> Option<HANDLE> {
    const THREAD_QUERY_SET_WIN32_START_ADDRESS: u32 = 9;

    let pe = game().pe;
    let pe_ep = pe.optional_header().ImageBase + pe.optional_header().AddressOfEntryPoint as u64;

    iter_threads(None).find(|&thread| unsafe {
        let mut thread_ep = 0;
        let status = NtQueryInformationThread(
            thread,
            THREAD_QUERY_SET_WIN32_START_ADDRESS,
            (&mut thread_ep as *mut u64).cast(),
            size_of_val(&thread_ep),
            null_mut(),
        );
        status >= 0 && thread_ep == pe_ep
    })
}

pub fn is_created_suspended(thread: HANDLE) -> bool {
    let mut context = CONTEXT::default();
    context.ContextFlags = CONTEXT_FULL_AMD64;

    if unsafe { GetThreadContext(thread, &mut context) } == 0 {
        return false;
    }

    context.Rip == RtlUserThreadStart as usize as u64
}
